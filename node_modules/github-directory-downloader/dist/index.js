'use strict';

var fs = require('fs-extra');
var fetch = require('node-fetch');
var path = require('path');
var util = require('util');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

const streamPipeline = util.promisify(require('stream').pipeline);
// Matches '/<re/po>/tree/<ref>/<dir>'
const urlParserRegex = /^[/]([^/]+)[/]([^/]+)[/]tree[/]([^/]+)[/](.*)/;
async function fetchRepoInfo(repo, token, muteLog) {
    const response = await fetch__default['default'](`https://api.github.com/repos/${repo}`, token ? {
        headers: {
            Authorization: `Bearer ${token}`
        }
    } : {});
    switch (response.status) {
        case 401:
            if (!muteLog)
                console.log('⚠ The token provided is invalid or has been revoked.', { token: token });
            throw new Error('Invalid token');
        case 403:
            // See https://developer.github.com/v3/#rate-limiting
            if (response.headers.get('X-RateLimit-Remaining') === '0') {
                if (!muteLog)
                    console.log('⚠ Your token rate limit has been exceeded.', { token: token });
                throw new Error('Rate limit exceeded');
            }
            break;
        case 404:
            if (!muteLog)
                console.log('⚠ Repository was not found.', { repo });
            throw new Error('Repository not found');
    }
    if (!response.ok) {
        if (!muteLog)
            console.log('⚠ Could not obtain repository data from the GitHub API.', { repo, response });
        throw new Error('Fetch error');
    }
    return response.json();
}
async function viaTreesApi({ user, repository, ref = 'HEAD', directory, token, muteLog }) {
    if (!directory.endsWith('/')) {
        directory += '/';
    }
    const files = [];
    const contents = await fetchRepoInfo(`${user}/${repository}/git/trees/${ref}?recursive=1`, token, muteLog);
    if (contents.message) {
        throw new Error(contents.message);
    }
    for (const item of contents.tree) {
        if (item.type === 'blob' && item.path.startsWith(directory)) {
            files.push(item);
        }
    }
    return files;
}
async function getRepoMeta(user, repository, ref, dir, config) {
    const repoIsPrivate = (await fetchRepoInfo(`${user}/${repository}`, config === null || config === void 0 ? void 0 : config.token, config === null || config === void 0 ? void 0 : config.muteLog)).private;
    const files = await viaTreesApi({
        user,
        repository,
        ref,
        directory: decodeURIComponent(dir),
        token: config === null || config === void 0 ? void 0 : config.token,
        muteLog: config === null || config === void 0 ? void 0 : config.muteLog,
    });
    return {
        files,
        repoIsPrivate
    };
}
const parseUrl = (source, muteLog) => {
    var _a;
    try {
        const [, user, repository, ref, dir] = (_a = urlParserRegex.exec(new URL(source).pathname)) !== null && _a !== void 0 ? _a : [];
        return [user, repository, ref, dir];
    }
    catch (e) { }
    return [];
};
async function download(source, saveTo, config) {
    var _a;
    const stats = { files: {}, downloaded: 0, success: false };
    const [user, repository, ref, dir] = parseUrl(source);
    if (!user || !repository) {
        if (!(config === null || config === void 0 ? void 0 : config.muteLog))
            console.error('Invalid url. It must match: ', urlParserRegex);
        stats.error = 'Invalid url';
        return stats;
    }
    if (!saveTo) {
        saveTo = path.resolve(process.cwd(), dir);
    }
    if (!path.isAbsolute(saveTo))
        saveTo = path.resolve(process.cwd(), saveTo);
    let meta;
    try {
        meta = await getRepoMeta(user, repository, ref, dir, config);
    }
    catch (e) {
        if (!(config === null || config === void 0 ? void 0 : config.muteLog))
            console.error('Failed to fetch repo meta info: ', e);
        await new Promise(resolve => setTimeout(resolve, 3000));
        try {
            meta = await getRepoMeta(user, repository, ref, dir, config);
        }
        catch (e) {
            if (!(config === null || config === void 0 ? void 0 : config.muteLog))
                console.error('Failed to fetch repo meta info after second attempt: ', e);
            stats.error = e;
            return stats;
        }
    }
    const { files, repoIsPrivate } = meta;
    if (files.length === 0) {
        if (!(config === null || config === void 0 ? void 0 : config.muteLog))
            console.log('No files to download');
        stats.success = true;
        return stats;
    }
    if (!(config === null || config === void 0 ? void 0 : config.muteLog))
        console.log(`Downloading ${files.length} files…`);
    const fetchFile = async (file) => {
        const response = await fetch__default['default'](`https://raw.githubusercontent.com/${user}/${repository}/${ref}/${file.path}`, (config === null || config === void 0 ? void 0 : config.token) ? {
            headers: {
                Authorization: `Bearer ${config === null || config === void 0 ? void 0 : config.token}`
            },
        } : undefined);
        if (!response.ok) {
            throw new Error(`HTTP ${response.statusText} for ${file.path}`);
        }
        return response;
    };
    let downloaded = 0;
    const download = async (file) => {
        let response;
        try {
            response = await fetchFile(file);
        }
        catch (e) {
            if (!(config === null || config === void 0 ? void 0 : config.muteLog))
                console.log('⚠ Failed to download file: ' + file.path, e);
            await new Promise(resolve => setTimeout(resolve, 2000));
            try {
                response = await fetchFile(file);
            }
            catch (e) {
                if (!(config === null || config === void 0 ? void 0 : config.muteLog))
                    console.log('⚠ Failed to download file after second attempt: ' + file.path, e);
                return;
            }
        }
        try {
            downloaded++;
            const fileName = path.resolve(saveTo, file.path.replace(dir + '/', ''));
            await fs__default['default'].ensureDir(path.dirname(fileName));
            await streamPipeline(response.body, fs__default['default'].createWriteStream(fileName));
            stats.files[file.path] = fileName;
        }
        catch (e) {
            if (!(config === null || config === void 0 ? void 0 : config.muteLog))
                console.error('Failed to write file: ' + file.path, e);
        }
    };
    const requests = (_a = config === null || config === void 0 ? void 0 : config.requests) !== null && _a !== void 0 ? _a : 10;
    const statuses = [];
    for (let i = 0; i < files.length; i++) {
        const num = i % requests;
        if (statuses[num]) {
            await statuses[num];
        }
        statuses[num] = download(files[i]);
    }
    await Promise.all(statuses);
    if (!(config === null || config === void 0 ? void 0 : config.muteLog))
        console.log(`Downloaded ${downloaded}/${files.length} files`);
    stats.downloaded = downloaded;
    if (files.length === downloaded)
        stats.success = true;
    return stats;
}

module.exports = download;
